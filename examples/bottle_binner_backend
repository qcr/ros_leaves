#!/usr/bin/env python
from __future__ import print_function

import actionlib
import cv_bridge
from random import randint
import rospy
from sensor_msgs.msg import Image
from std_msgs.msg import Header
import sys

from qut_msgs.msg import (ActuateGripperAction, ActuateGripperGoal,
                          ActuateGripperResult, MoveToNamedLocationAction,
                          MoveToNamedLocationResult, MoveToPoseAction,
                          MoveToPoseResult, Object)
from qut_msgs.srv import (GetSyncedImages, GetSyncedImagesResponse,
                          FindObjects, FindObjectsResponse)


class DummyBottleBinnerBackend(object):
    IMAGE_WIDTH = 640
    IMAGE_HEIGHT = 480

    def __init__(self):
        self._bridge = cv_bridge.CvBridge()

        # Startup all of our fake services...
        self._actuate_gripper_as = actionlib.SimpleActionServer(
            '/action/actuate_gripper',
            ActuateGripperAction,
            self.cb_actuate_gripper,
            auto_start=False)
        self._detect_bottles_service = rospy.Service('/service/detect_bottles',
                                                     FindObjects,
                                                     self.cb_detect_bottles)
        self._synced_rgbd_service = rospy.Service('/service/get_synced_rgbd',
                                                  GetSyncedImages,
                                                  self.cb_get_synced_rgbd)
        self._move_gripper_location_as = actionlib.SimpleActionServer(
            '/action/move_gripper/location',
            MoveToNamedLocationAction,
            self.cb_move_gripper_location,
            auto_start=False)
        self._move_gripper_pose_as = actionlib.SimpleActionServer(
            '/action/move_gripper/pose',
            MoveToPoseAction,
            self.cb_move_gripper_pose,
            auto_start=False)

        self._actuate_gripper_as.start()
        self._move_gripper_location_as.start()
        self._move_gripper_pose_as.start()

        print("All dummy services are now running...")

    @staticmethod
    def _print_dramatic(string, delay):
        print(string + " ... ", end="")
        sys.stdout.flush()
        rospy.sleep(delay)
        print("Done")

    def cb_actuate_gripper(self, goal):
        # Print some dummy output
        success = (goal.mode == ActuateGripperGoal.MODE_STATE)
        if success:
            self._print_dramatic(
                "%s gripper" %
                ("Opening" if goal.state == ActuateGripperGoal.STATE_OPEN else
                 "Closing"), 0.5)
        else:
            print("Doing something with the gripper I'm not expecting... ")

        # Return an appropriate result
        (self._actuate_gripper_as.set_succeeded if success else
         self._actuate_gripper_as.set_aborted)(ActuateGripperResult())

    def cb_detect_bottles(self, req):
        # Generate some random detections within the images...
        # TODO access to ros_numpy would be nice...
        object_dims = [
            (randint(5, 50), randint(5, 50)) for i in range(0, randint(1, 5))
        ]
        object_coords = [(randint(0, self.IMAGE_WIDTH - d[0]),
                          randint(0, self.IMAGE_HEIGHT - d[1]))
                         for d in object_dims]
        object_indices = []
        for d, c in zip(object_dims, object_coords):
            stacked = [
                list(range(r + c[0], r + c[0] + d[0]))
                for r in range(c[1], c[1] + d[1])
            ]
            object_indices.append([i for ii in stacked for i in ii])
        self._print_dramatic("Detecting bottles", 0.1)
        return FindObjectsResponse(objects=[
            Object(class_label='bottle',
                   x_left=c[0],
                   y_top=c[1],
                   width=d[0],
                   height=d[1],
                   cropped_depth=Image(header=req.input_depth_image.header,
                                       width=d[0],
                                       height=d[1],
                                       encoding=req.input_depth_image.encoding,
                                       step=d[0],
                                       data=req.input_depth_image.data))
            for d, c in zip(object_dims, object_coords)
        ])

    def cb_get_synced_rgbd(self, req):
        # Return a response with some dummy images
        # TODO access to ros_numpy would be nice...
        self._print_dramatic("Getting synced RGBD", 0.1)
        return GetSyncedImagesResponse(
            synced_depth_image=Image(
                header=Header(frame_id=req.camera_namespace),
                height=self.IMAGE_HEIGHT,
                width=self.IMAGE_WIDTH,
                step=self.IMAGE_WIDTH,
                encoding='mono8',
                data=[
                    randint(100, 255)
                    for i in range(0, self.IMAGE_WIDTH * self.IMAGE_HEIGHT)
                ]),
            synced_rgb_image=Image(
                header=Header(frame_id=req.camera_namespace),
                height=self.IMAGE_HEIGHT,
                width=self.IMAGE_WIDTH,
                step=self.IMAGE_WIDTH * 3,
                encoding='rgb8',
                data=[
                    randint(0, 255)
                    for i in range(0, self.IMAGE_WIDTH * self.IMAGE_HEIGHT * 3)
                ]))

    def cb_move_gripper_location(self, goal):
        success = goal.location_name in ['bin', 'workspace']
        if success:
            self._print_dramatic(
                "Moving gripper to location '%s'" % goal.location_name, 5)
        else:
            print("I do not know the location '%s' ... Aborting" %
                  goal.location_name)

        # Return an appropriate result
        (self._move_gripper_location_as.set_succeeded
         if success else self._move_gripper_location_as.set_aborted)(
             MoveToNamedLocationResult())

    def cb_move_gripper_pose(self, goal):
        pos = goal.goal_pose.pose.position
        self._print_dramatic(
            "Moving gripper to location (%f, %f, %f) in frame '%s'" %
            (pos.x, pos.y, pos.z, goal.goal_pose.header.frame_id), 5)

        # Return an appropriate result
        self._move_gripper_pose_as.set_succeeded(MoveToPoseResult())


if __name__ == '__main__':
    rospy.init_node("dummy_bottle_binner_backend")
    dbbs = DummyBottleBinnerBackend()
    rospy.spin()
